name: Smoke Tests - (Linux Docker) DaemonSet

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build images locally
        run: |
          echo "Building sidecar/DaemonSet exporter image locally..."
          docker build -t gunicorn-prometheus-exporter:test .
          echo "‚úÖ Exporter image built successfully"

          echo "Building sample app image locally..."
          docker build -f docker/Dockerfile.app -t gunicorn-app:test .
          echo "‚úÖ Sample app image built successfully"

      - name: Test Kubernetes DaemonSet deployment
        run: |
          echo "Testing Kubernetes DaemonSet deployment with Redis storage..."

          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

          # Install kind (Kubernetes in Docker)
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind

          # Create a kind cluster with multiple nodes for DaemonSet testing
          cat <<EOF > kind-config.yaml
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
          - role: control-plane
          - role: worker
          - role: worker
          EOF

          kind create cluster --name daemonset-test --config kind-config.yaml --wait 300s

          # Load our Docker images into the kind cluster
          kind load docker-image gunicorn-prometheus-exporter:test --name daemonset-test
          kind load docker-image gunicorn-app:test --name daemonset-test

          # Create temporary copies of manifests
          mkdir -p /tmp/k8s-daemonset-test
          cp k8s/*.yaml /tmp/k8s-daemonset-test/

          # Update image references in DaemonSet manifest
          sed -i -E "s|princekrroshan01/gunicorn-app:[^\"[:space:]]*|gunicorn-app:test|g" /tmp/k8s-daemonset-test/sidecar-daemonset.yaml
          sed -i -E "s|princekrroshan01/gunicorn-prometheus-exporter:[^\"[:space:]]*|gunicorn-prometheus-exporter:test|g" /tmp/k8s-daemonset-test/sidecar-daemonset.yaml

          # Deploy Redis first (required for DaemonSet)
          echo "Deploying Redis..."
          kubectl apply -f /tmp/k8s-daemonset-test/redis-pvc.yaml
          kubectl apply -f /tmp/k8s-daemonset-test/redis-deployment.yaml
          kubectl apply -f /tmp/k8s-daemonset-test/redis-service.yaml

          # Wait for Redis to be ready
          echo "Waiting for Redis to be ready..."
          kubectl wait --for=condition=ready pod -l app=redis --timeout=300s

          # Verify Redis is accessible
          echo "Verifying Redis connectivity..."
          kubectl run redis-test --image=redis:7-alpine --rm -i --restart=Never -- redis-cli -h redis-service ping

          # Deploy the DaemonSet
          echo "Deploying DaemonSet..."
          kubectl apply -f /tmp/k8s-daemonset-test/sidecar-daemonset.yaml
          kubectl apply -f /tmp/k8s-daemonset-test/daemonset-service.yaml
          kubectl apply -f /tmp/k8s-daemonset-test/daemonset-metrics-service.yaml

          # Wait for DaemonSet pods to be ready (should be 2 pods for 2 worker nodes)
          echo "Waiting for DaemonSet pods to be ready..."
          if ! kubectl wait --for=condition=ready pod -l app=gunicorn-prometheus-exporter,component=daemonset --timeout=300s; then
            echo "‚ùå DaemonSet pods failed to become ready"
            kubectl get pods -l app=gunicorn-prometheus-exporter,component=daemonset
            kubectl describe pods -l app=gunicorn-prometheus-exporter,component=daemonset
            echo "--- App container logs ---"
            kubectl logs -l app=gunicorn-prometheus-exporter,component=daemonset -c app --tail=200 || true
            echo "--- Prometheus exporter sidecar logs ---"
            kubectl logs -l app=gunicorn-prometheus-exporter,component=daemonset -c prometheus-exporter --tail=200 || true
            exit 1
          fi

          # Verify DaemonSet deployed to all worker nodes
          echo "Verifying DaemonSet deployment..."
          ds_desired=$(kubectl get daemonset gunicorn-prometheus-exporter-daemonset -o jsonpath='{.status.desiredNumberScheduled}')
          ds_ready=$(kubectl get daemonset gunicorn-prometheus-exporter-daemonset -o jsonpath='{.status.numberReady}')

          echo "DaemonSet desired pods: $ds_desired"
          echo "DaemonSet ready pods: $ds_ready"

          if [ "$ds_ready" -lt 2 ]; then
            echo "‚ùå DaemonSet not deployed to sufficient nodes (expected 2+, got $ds_ready)"
            kubectl get daemonset gunicorn-prometheus-exporter-daemonset
            exit 1
          fi

          echo "‚úÖ DaemonSet successfully deployed to $ds_ready nodes"

          # Set up port forwarding for testing
          kubectl port-forward service/daemonset-service 8000:8000 &
          PF_APP_PID=$!
          kubectl port-forward service/daemonset-metrics-service 9091:9091 &
          PF_METRICS_PID=$!

          # Wait for port forwarding to be ready
          sleep 15

          # Test application health
          echo "Testing application health..."
          if ! curl -f --max-time 10 http://localhost:8000/health; then
            echo "‚ùå Application health check failed"
            kubectl logs -l app=gunicorn-prometheus-exporter,component=daemonset -c app --tail=200 || true
            kill $PF_APP_PID $PF_METRICS_PID || true
            exit 1
          fi
          echo "‚úÖ Application is healthy"

          # Generate requests to create metrics
          echo "Generating test requests to create metrics..."
          for i in {1..20}; do
            curl -s http://localhost:8000/ > /dev/null || true
            curl -s http://localhost:8000/health > /dev/null || true
            sleep 0.5
          done

          # Wait for metrics to be collected and stored in Redis
          echo "Waiting for metrics to be collected and aggregated via Redis..."
          sleep 10

          # Fetch and validate metrics
          echo "Verifying comprehensive metrics collection from DaemonSet..."
          metrics_response=$(curl -f --max-time 10 http://localhost:9091/metrics 2>/dev/null)

          if [ -z "$metrics_response" ]; then
            echo "‚ùå No metrics response from DaemonSet metrics endpoint"
            kubectl logs -l app=gunicorn-prometheus-exporter,component=daemonset -c prometheus-exporter --tail=200 || true
            kill $PF_APP_PID $PF_METRICS_PID || true
            exit 1
          fi

          # Validate critical worker metrics
          echo "=== Validating Critical Worker Metrics ==="

          echo "Checking for gunicorn_worker_requests_total..."
          if echo "$metrics_response" | grep -q "gunicorn_worker_requests_total.*[0-9]"; then
            request_count=$(echo "$metrics_response" | grep "gunicorn_worker_requests_total" | wc -l)
            echo "‚úÖ Found gunicorn_worker_requests_total ($request_count counters)"

            # Verify actual request values
            total_requests=$(echo "$metrics_response" | grep "gunicorn_worker_requests_total" | awk '{print $NF}' | awk '{sum+=$1} END {print sum}')
            if [ "$total_requests" != "" ] && [ "$total_requests" != "0" ]; then
              echo "‚úÖ Total requests tracked: $total_requests"
            else
              echo "‚ùå No requests were tracked"
              exit 1
            fi
          else
            echo "‚ùå gunicorn_worker_requests_total metric missing or has no values"
            exit 1
          fi

          echo "Checking for gunicorn_worker_request_duration_seconds..."
          if echo "$metrics_response" | grep -q "gunicorn_worker_request_duration_seconds.*[0-9]"; then
            duration_count=$(echo "$metrics_response" | grep "gunicorn_worker_request_duration_seconds" | wc -l)
            echo "‚úÖ Found gunicorn_worker_request_duration_seconds ($duration_count data points)"
          else
            echo "‚ùå gunicorn_worker_request_duration_seconds metric missing or has no values"
            exit 1
          fi

          echo "Checking for gunicorn_worker_memory_bytes..."
          if echo "$metrics_response" | grep -q "gunicorn_worker_memory_bytes.*[0-9]"; then
            memory_count=$(echo "$metrics_response" | grep "gunicorn_worker_memory_bytes" | wc -l)
            echo "‚úÖ Found gunicorn_worker_memory_bytes ($memory_count data points)"
          else
            echo "‚ùå gunicorn_worker_memory_bytes metric missing or has no values"
            exit 1
          fi

          echo "Checking for gunicorn_worker_cpu_percent..."
          if echo "$metrics_response" | grep -q "gunicorn_worker_cpu_percent.*[0-9]"; then
            cpu_count=$(echo "$metrics_response" | grep "gunicorn_worker_cpu_percent" | wc -l)
            echo "‚úÖ Found gunicorn_worker_cpu_percent ($cpu_count data points)"
          else
            echo "‚ùå gunicorn_worker_cpu_percent metric missing or has no values"
            exit 1
          fi

          echo "Checking for gunicorn_worker_uptime_seconds..."
          if echo "$metrics_response" | grep -q "gunicorn_worker_uptime_seconds.*[0-9]"; then
            uptime_count=$(echo "$metrics_response" | grep "gunicorn_worker_uptime_seconds" | wc -l)
            echo "‚úÖ Found gunicorn_worker_uptime_seconds ($uptime_count data points)"
          else
            echo "‚ùå gunicorn_worker_uptime_seconds metric missing or has no values"
            exit 1
          fi

          echo "Checking for gunicorn_worker_state..."
          if echo "$metrics_response" | grep -q "gunicorn_worker_state.*[0-9]"; then
            worker_state_count=$(echo "$metrics_response" | grep "gunicorn_worker_state" | wc -l)
            echo "‚úÖ Found gunicorn_worker_state ($worker_state_count workers)"
          else
            echo "‚ùå gunicorn_worker_state metric missing or has no values"
            exit 1
          fi

          # Validate master-level metrics (optional but good to check)
          echo ""
          echo "=== Validating Master-Level Metrics (Optional) ==="

          echo "Checking for gunicorn_master_worker_restart_total..."
          if echo "$metrics_response" | grep -q "gunicorn_master_worker_restart_total"; then
            echo "‚úÖ Found gunicorn_master_worker_restart_total"
          else
            echo "‚ö†Ô∏è  gunicorn_master_worker_restart_total not found (normal if no restarts)"
          fi

          echo "Checking for gunicorn_master_worker_restart_count_total..."
          if echo "$metrics_response" | grep -q "gunicorn_master_worker_restart_count_total"; then
            echo "‚úÖ Found gunicorn_master_worker_restart_count_total"
          else
            echo "‚ö†Ô∏è  gunicorn_master_worker_restart_count_total not found (normal if no restarts)"
          fi

          echo "Checking for gunicorn_worker_restart_total..."
          if echo "$metrics_response" | grep -q "gunicorn_worker_restart_total"; then
            echo "‚úÖ Found gunicorn_worker_restart_total"
          else
            echo "‚ö†Ô∏è  gunicorn_worker_restart_total not found (normal if no restarts)"
          fi

          echo "Checking for gunicorn_worker_restart_count_total..."
          if echo "$metrics_response" | grep -q "gunicorn_worker_restart_count_total"; then
            echo "‚úÖ Found gunicorn_worker_restart_count_total"
          else
            echo "‚ö†Ô∏è  gunicorn_worker_restart_count_total not found (normal if no restarts)"
          fi

          echo "Checking for gunicorn_master_restart_total..."
          if echo "$metrics_response" | grep -q "gunicorn_master_restart_total"; then
            echo "‚úÖ Found gunicorn_master_restart_total"
          else
            echo "‚ö†Ô∏è  gunicorn_master_restart_total not found (normal if no master restarts)"
          fi

          # Validate metric types
          echo ""
          echo "=== Validating Metric Types ==="

          if echo "$metrics_response" | grep -q "# TYPE.*counter"; then
            counter_types=$(echo "$metrics_response" | grep "# TYPE.*counter" | wc -l)
            echo "‚úÖ Counter metrics found ($counter_types types)"
          else
            echo "‚ùå No counter metrics found"
            exit 1
          fi

          if echo "$metrics_response" | grep -q "# TYPE.*gauge"; then
            gauge_types=$(echo "$metrics_response" | grep "# TYPE.*gauge" | wc -l)
            echo "‚úÖ Gauge metrics found ($gauge_types types)"
          else
            echo "‚ùå No gauge metrics found"
            exit 1
          fi

          if echo "$metrics_response" | grep -q "# TYPE.*histogram"; then
            histogram_types=$(echo "$metrics_response" | grep "# TYPE.*histogram" | wc -l)
            echo "‚úÖ Histogram metrics found ($histogram_types types)"
          else
            echo "‚ùå No histogram metrics found"
            exit 1
          fi

          # Check for worker ID labels
          if echo "$metrics_response" | grep -q "worker_id="; then
            echo "‚úÖ Worker ID labels found"
          else
            echo "‚ùå No worker ID labels found"
            exit 1
          fi

          # Count total metric samples
          total_samples=$(echo "$metrics_response" | grep -c "^[^#]" || echo "0")
          echo ""
          echo "üìä Total metric samples: $total_samples"

          if [ "$total_samples" -ge 50 ]; then
            echo "‚úÖ Sufficient metric samples found ($total_samples)"
          else
            echo "‚ùå Insufficient metric samples ($total_samples, expected 50+)"
            exit 1
          fi

          # Count total worker metrics
          total_worker_metrics=$(echo "$metrics_response" | grep -c "^gunicorn_worker_" || echo "0")
          echo "üìä Total gunicorn_worker metrics found: $total_worker_metrics"

          if [ "$total_worker_metrics" -ge 10 ]; then
            echo "‚úÖ Comprehensive DaemonSet worker metrics validation passed"
          else
            echo "‚ùå Only found $total_worker_metrics worker metrics (expected 10+)"
            exit 1
          fi

          # Verify Redis integration is working
          echo "=== Verifying Redis Integration ==="

          # Check Redis keys from within the cluster
          echo "Checking Redis keys..."
          redis_keys=$(kubectl run redis-check --image=redis:7-alpine --rm -i --restart=Never -- \
            redis-cli -h redis-service --scan --pattern "gunicorn*" | wc -l || echo "0")

          echo "Redis keys found: $redis_keys"

          if [ "$redis_keys" -gt 10 ]; then
            echo "‚úÖ Redis integration working ($redis_keys keys found)"
          else
            echo "‚ö†Ô∏è  Limited Redis keys found ($redis_keys) - metrics may be using multiprocess files"
          fi

          # Verify DaemonSet-specific features
          echo "=== Verifying DaemonSet-Specific Features ==="

          # Check if node information is present in metrics
          if echo "$metrics_response" | grep -q "node_name"; then
            echo "‚úÖ Node name labels found in metrics"
          else
            echo "‚ö†Ô∏è  Node name labels not found (may not be critical)"
          fi

          # Check if pod information is present
          if echo "$metrics_response" | grep -q "pod_name"; then
            echo "‚úÖ Pod name labels found in metrics"
          else
            echo "‚ö†Ô∏è  Pod name labels not found (may not be critical)"
          fi

          # Verify metrics from multiple nodes (if DaemonSet deployed to multiple nodes)
          if [ "$ds_ready" -gt 1 ]; then
            echo "‚úÖ Metrics collected from multiple DaemonSet pods ($ds_ready nodes)"
          fi

          # Test that application container and exporter sidecar are communicating
          echo "=== Verifying Container Communication ==="

          # Check logs for successful metric collection
          echo "Checking exporter sidecar logs..."
          sidecar_logs=$(kubectl logs -l app=gunicorn-prometheus-exporter,component=daemonset -c prometheus-exporter --tail=50 || echo "")

          if echo "$sidecar_logs" | grep -q -E "(Started|Collecting|Metrics|Ready)"; then
            echo "‚úÖ Exporter sidecar is actively collecting metrics"
          else
            echo "‚ö†Ô∏è  Exporter sidecar logs may not show active collection"
          fi

          # Stop port-forward background jobs
          kill $PF_APP_PID $PF_METRICS_PID || true

          # Final validation summary
          echo ""
          echo "==================================="
          echo "‚úÖ DaemonSet Deployment Test PASSED"
          echo "==================================="
          echo "‚úÖ DaemonSet deployed to $ds_ready nodes"
          echo "‚úÖ Redis storage integration verified"
          echo "‚úÖ Application container running"
          echo "‚úÖ Exporter sidecar collecting metrics"
          echo "‚úÖ All critical metrics present"
          echo "‚úÖ Metrics accessible via service"
          echo "==================================="

          # Cleanup
          pkill -f "kubectl port-forward" || true
          kind delete cluster --name daemonset-test

          echo "‚úÖ Kubernetes DaemonSet deployment test completed successfully!"

      - name: Summary
        run: |
          echo "üéâ All DaemonSet tests passed!"
          echo "‚úÖ DaemonSet deployment works correctly"
          echo "‚úÖ Redis storage integration verified"
          echo "‚úÖ Multi-node deployment verified"
          echo "‚úÖ Application and exporter sidecar communication verified"
          echo "‚úÖ All metrics collected and exposed properly"
